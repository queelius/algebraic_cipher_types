/*****
 * 
 * Anything that models a cipher type should have a hash(x)
 * function so that they may be composed.
 * 
 * For intance, if I have an x of type cipher_string that models a cipher
 * type, then hash(x) is defined.
 * 
 * Now, I can construct a set of these in various ways. One is to just do
 * the xor thing described elsewhere but of this approach only permits
 * equality and union operations... I could also make a cipher set that
 * permits contains queries using the cipher map model. This cipher map model
 * will take a vector of cipher_string and make a cipher set. However, if
 * each plaintext element x of type X maps to a set of cipher_string
 * representations, for homophonic encryption for instance, then only having
 * individual representations is not enough, but the cipher map may be
 * still constructed if the cipher_string generator is available. So,
 * we iterate through the strings in the set A of type 2^string, map them to
 * values of type cipher_string, then iterate over each cipher_string
 * to get all the representations for each, and then generate the cipher
 * map (or cipher set), e.g., cipher_set<cipher_string> which has a predicate
 * bool contains : cipher_set<cipher_string> -> cipher_string -> cipher_bool.
 * 
 * Should cipher_string be cipher<string>? probably, now its a monad of sorts.
 * we're lifting it.
 * 
 * 
 * the trapdoor is interesting. i think almost all cipher values can be
 * modeled as this. the cipher_set<cipher_string> has a to_hash() function
 * also, for instance, and now we can, for instance, generate
 * a cipher_set<cipher_set<cipher_string>> by taking a list of
 * cipher_set<cipher_string> and making it.
 * 
 * however, now we see again, that such a cipher_set<cipher_set<cipher_string>>
 * value, given two independent such sets, will have either the same or diff.
 * representations. if same rep, then we have the frequency / correlation
 * problem as before, but we can treat it like a normal cipher_set.
 * 
 * if each cipher_set is also a random variable a priori, then having a
 * particular realization of a cipher_set<cipher_string> as the elements
 * of cipher_set<cipher_set<cipher_string>> is incomplete. as before, though,
 * if we have the generators and the secret, we could in theory make *all*
 * such cipher_sets for a given cipher_set<cipher_string>... but there could
 * be *many* such representations (even countably infinite many, unless rate
 * distortion is imposed). 
 */


#pragma once

#include "lg.hpp"
#include <string_view>

unsigned int hash(std::string_view x)
{
    return 0;
}

/**
 * trapdoor<X> is a regular type.
 *
 * A trapdoor of X is a one-way transformation of values of type X
 * to trapdoor<X>. Let the one-way transformation be denoted by
 *     make_trapdoor : {0,1}^* -> X -> trapdoor<X>,
 * where the first argumen is a secret key.
 * 
 * Then, the partial application
 *     T(x) := \x -> make_trapdoor(s,x)
 * is of type X -> trapdoor<X> where s is the secret.
 * 
 * T is one-way in two independent senses:
 * 
 *     (1) T is easy to compute, but its "inverse" U : trapdoor<X> -> 2^X
 *         is (generally) hard.
 * 
 *     (2) Since T is (generally) non-invertible, U(t) := { x in X | T(x) = t }
 *         and thus each t in trapdoor<X> may map to multiple values in X.
 *
 *         In many cases, such as when X is a the free semigroup of a finite alphabet,
 *         U(t) is countably infinite for any t in trapdoor<X>. Thus, revealing
 *         which values U(t) maps to may not be very informative.
 * 
 * Note that trapdoor<X> is an *approximate cipher value type* since the value
 * of a t of type trapdoor<X> is difficult, if not impossible, to decipher
 * to its objective value of type X.
 * 
 * Furthermore, since == : trapdoor<X> -> trapdoor<X> -> bool (and its
 * complement) can be trivially defined (note that a cipher map could be
 * separately constructed for == which is not approximate), trapdoor<X>
 * is an *approximate* value type with respect to == and !=.
 * 
 * 
 * Few operations for this type can be defined on the basis of the hash
 * values alone. Cipher maps may be used to operate on these trapdoors more
 * generally, but they require access to the preimage hash values, i.e.,
 * either they require U(t) (which is expensive and is not one-to-one) or
 * the cipher maps were generated by someone who has access to the secret.
 * 
 * 
 */



template <typename X>
struct trapdoor
{
    using value_type = X;

    static constexpr auto KEY_BYTE_LENGTH = sizeof(value_hash);
    static constexpr auto KEY_BIT_LENGTH = CHAR_BIT * KEY_BYTE_LENGTH;

    trapdoor() : {}
    trapdoor(trapdoor const &) = default;
    
    trapdoor& operator=(trapdoor const & rhs)
    {
        value_hash = rhs.value_hash;
        key_hash = rhs.key_hash;
    }

    unsigned int value_hash;

    // the key hash is a hash of the secret key,
    // which faciliates a form of dynamic type checking.
    unsigned int key_hash;
};

template <typename X>
trapdoor<X> make_trapdoor(
    X const & x,
    std::string_view k)
{
    return trapdoor<X>(x,k);
}

// Equality for trapdoor<X> is defined as both the secret hash and the value
// hash being equal.
//
// Thus, the probability that two different trapdoors x and y are falsely
// computed to be equal is given by
//     P[make_trapdoor(x,s) == make_trapdoor(y,k) | x != y or s != k],
// which may be rewritten as
//     P[h(x) ^ h(s) == h(y) ^ h(k) && h(s) == h(k) | x != y or s != k].
// Assuming h is cryptographic, this may be simplified to
//     P[h(x) ^ h(s) == h(y) ^ h(k) | x != y or s != k] *
//         P[h(k) == h(s) | s != k].
//
// 
//
//
// which is a problematic probability to evaluate.
//
// We simply matters by assuming that the probability that s and k falsely
// hash to the same value is 0.
//
// The probability P[trapdoor(x,k) == trapdoor(y,k) | x != y],
// assuming a cryptographic hash function, is the probabiliity that
// they both hash to the same value, 1 / n, where n-1 is the maximum
// value of unsigned int. 
//
// The probability P[trapdoor(x,k) == trapdoor(x,k)] = 1.
// However, we must also consider the fact that the secret keys may be
// different but hash to the same value., P[trapdoor(x,k) == trapdoor(x,l) | k != l].
// Thus, they are independent and the probability that they map to the
// same value is again 1 / n. However, the probability that the secret hashes
// of k and l map to the same hash is 1 / n also. If they map to the same
// hash, then 


template <typename X>
unsigned int hash(trapdoor<X> const & x)
{
    return x.value_hash;
}

template <typename T>
struct equality_pred
{
    static auto operator()(T const & x, T const & y)
    {
        return x == y;
    }
};

template <typename T>
struct inequality_pred
{
    static auto operator()(T const & x, T const & y)
    {
        return x != y;
    }
};


template <typename T>
struct approximation_error {};

/**
 * Approximation errors on predicates
 * have exactly two types of errors,
 * false positives and false negatives.
 * 
 * Suppose we have an approximation
 * x' of x.
 * 
 * The false positive rate is given by
 *     P[p(x') | ~p(x)]
 * and the false negative rate is given by
 *     P[~p(x') | p(x)].
 * 
 * A well-defined predicate P for an approximate
 * type T defines a structure
 * 
 *     struct<approximation_error<P<T>>.
 * 
 * If P is unary, then it defines the function
 *     fpr : struct<approximation_error<P<T>> -> [0,1]
 * which maps the predicate 
 * 
 * 
 * 
 */


template <typename X>
struct approximation_error<equality_pred<trapdoor<X>>>
{
    // 2^(-k)
    //
    // log2(x) = ln(x)/ln(2)
    // ln(x) = log2(x) * ln(2)
    //
    // ln(x) = -k * ln(2)
    // 
    auto fpr() const
    {
        return lg<double>{-(double)trapdoor<X>::KEY_BIT_LENGTH * log(2.0)};
    }

    auto fnr() const
    {
        return lg<double>{0};
    }
};

template <typename X>
struct approximation_error<inequality_pred<trapdoor<X>>>
{
    auto fpr() const
    {
        return lg<double>(0);
    }

    auto fnr() const
    {
        return lg<double>(0);
    }
};


template <typename X>
bool operator==(trapdoor<X> const & x, trapdoor<X> const & y)
{
    return x.key_hash == y.key_hash && x.value_hash == y.value_hash;
}

template <typename X>
bool operator!=(trapdoor<X> const & x, trapdoor<X> const & y)
{
    return x.key_hash != y.key_hash && x.value_hash != y.value_hash;
}

template <typename X, typename Y>
bool operator==(trapdoor<X> const &, trapdoor<Y> const &)
{
    return false;
}


// key_hash(hash(k)), value_hash(hash(x) ^ key_hash) {}