#pragma once

#include "log_rate.hpp"

unsigned int hash(string_view x)
{
    return 0;
}

/**
 * trapdoor<X> is a regular type.
 *
 * A trapdoor of X is a one-way transformation of values of type X
 * to trapdoor<X>. Let the one-way transformation be denoted by
 *     make_trapdoor : {0,1}^* -> X -> trapdoor<X>,
 * where the first argumen is a secret key.
 * 
 * Then, the partial application
 *     T(x) := \x -> make_trapdoor(s,x)
 * is of type X -> trapdoor<X> where s is the secret.
 * 
 * T is one-way in two independent senses:
 * 
 *     (1) T is easy to compute, but its "inverse" U : trapdoor<X> -> 2^X
 *         is (generally) hard.
 * 
 *     (2) Since T is (generally) non-invertible, U(t) := { x in X | T(x) = t }
 *         and thus each t in trapdoor<X> may map to multiple values in X.
 *
 *         In many cases, such as when X is a the free semigroup of a finite alphabet,
 *         U(t) is countably infinite for any t in trapdoor<X>. Thus, revealing
 *         which values U(t) maps to may not be very informative.
 * 
 * Note that trapdoor<X> is an *approximate cipher value type* since the value
 * of a t of type trapdoor<X> is difficult, if not impossible, to decipher
 * to its objective value of type X.
 * 
 * Furthermore, since == : trapdoor<X> -> trapdoor<X> -> bool (and its
 * complement) can be trivially defined (note that a cipher map could be
 * separately constructed for == which is not approximate), trapdoor<X>
 * is an *approximate* value type with respect to == and !=.
 * 
 * 
 * Few operations for this type can be defined on the basis of the hash
 * values alone. Cipher maps may be used to operate on these trapdoors more
 * generally, but they require access to the preimage hash values, i.e.,
 * either they require U(t) (which is expensive and is not one-to-one) or
 * the cipher maps were generated by someone who has access to the secret.
 * 
 * 
 */
template <typename X>
struct trapdoor
{
    using value_type = X;

    trapdoor() : {}

    trapdoor(X const & x, string_view k) :
        key_hash(hash(k)), value_hash(hash(x) ^ key_hash) {}

    unsigned int value_hash;

    // the key hash is a hash of the secret key,
    // which faciliates a form of dynamic type checking.
    unsigned int key_hash;
};

template <typename X>
trapdoor<X> make_trapdoor(
    X const & x,
    string_view k)
{
    return trapdoor<X>(x,k);
}

// Equality for trapdoor<X> is defined as both the secret hash and the value
// hash being equal.
//
// Thus, the probability that two different trapdoors x and y are falsely
// computed to be equal is given by
//     P[make_trapdoor(x,s) == make_trapdoor(y,k) | x != y or s != k],
// which may be rewritten as
//     P[h(x) ^ h(s) == h(y) ^ h(k) && h(s) == h(k) | x != y or s != k].
// Assuming h is cryptographic, this may be simplified to
//     P[h(x) ^ h(s) == h(y) ^ h(k) | x != y or s != k] *
//         P[h(k) == h(s) | s != k].
//
// 
//
//
// which is a problematic probability to evaluate.
//
// We simply matters by assuming that the probability that s and k falsely
// hash to the same value is 0.
//
// The probability P[trapdoor(x,k) == trapdoor(y,k) | x != y],
// assuming a cryptographic hash function, is the probabiliity that
// they both hash to the same value, 1 / n, where n-1 is the maximum
// value of unsigned int. 
//
// The probability P[trapdoor(x,k) == trapdoor(x,k)] = 1.
// However, we must also consider the fact that the secret keys may be
// different but hash to the same value., P[trapdoor(x,k) == trapdoor(x,l) | k != l].
// Thus, they are independent and the probability that they map to the
// same value is again 1 / n. However, the probability that the secret hashes
// of k and l map to the same hash is 1 / n also. If they map to the same
// hash, then 

template <typename X, typename Op>
constexpr log_rate fpr_equality(trapdoor<X> const &)
{
    return log_rate{CHAR_BIT * sizeof(decltype(trapdoor<X>::value_hash))};
}

template <typename X, typename Op>
constexpr log_rate fnr_equality(trapdoor<X> const &)
{
    return log_rate{};
}


template <typename X>
bool operator==(trapdoor<X> const & x, trapdoor<X> const & y)
{
    return x.key_hash == y.key_hash && x.value_hash == y.value_hash;
}

template <typename X>
bool operator!=(trapdoor<X> const & x, trapdoor<X> const & y)
{
    return x.key_hash != y.key_hash && x.value_hash != y.value_hash;
}


